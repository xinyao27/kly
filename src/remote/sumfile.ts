import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { homedir } from "node:os";
import { dirname, join } from "node:path";

/**
 * Sum file entry representing a trusted code hash
 */
export interface SumEntry {
  /** Full URL: github.com/owner/repo@ref */
  url: string;
  /** Integrity hash: sha384-base64... */
  hash: string;
  /** Unix timestamp when first trusted */
  timestamp: number;
  /** Whether user explicitly trusted this code */
  trusted: boolean;
}

/**
 * Verification result
 */
export type VerifyResult = "ok" | "mismatch" | "new";

/**
 * Get the path to kly.sum file
 */
export function getSumFilePath(): string {
  return join(homedir(), ".kly", "kly.sum");
}

/**
 * Manager for kly.sum file (integrity verification database)
 *
 * File format (one entry per line):
 * github.com/owner/repo@ref sha384-hash timestamp trusted|untrusted
 *
 * Example:
 * github.com/jack/weather@v1.0.0 sha384-oqVuAfXRKap7fdgc... 1704067200 trusted
 */
export class SumFileManager {
  private entries: Map<string, SumEntry> = new Map();
  private sumFilePath: string;
  private dirty = false;

  constructor(sumFilePath?: string) {
    this.sumFilePath = sumFilePath || getSumFilePath();
    this.load();
  }

  /**
   * Load entries from kly.sum file
   */
  private load(): void {
    if (!existsSync(this.sumFilePath)) {
      return;
    }

    try {
      const content = readFileSync(this.sumFilePath, "utf-8");
      const lines = content.split("\n");

      for (const line of lines) {
        const trimmed = line.trim();

        // Skip empty lines and comments
        if (!trimmed || trimmed.startsWith("#")) {
          continue;
        }

        const entry = this.parseLine(trimmed);
        if (entry) {
          this.entries.set(entry.url, entry);
        }
      }
    } catch (error) {
      console.warn(`Warning: Failed to load kly.sum: ${error}`);
    }
  }

  /**
   * Parse a single line from kly.sum
   */
  private parseLine(line: string): SumEntry | null {
    // Format: url hash timestamp trusted|untrusted
    const parts = line.split(/\s+/);

    if (parts.length < 4) {
      return null;
    }

    const [url, hash, timestampStr, trustedStr] = parts;

    if (!url || !hash || !timestampStr || !trustedStr) {
      return null;
    }

    const timestamp = Number(timestampStr);
    if (Number.isNaN(timestamp)) {
      return null;
    }

    return {
      url,
      hash,
      timestamp,
      trusted: trustedStr === "trusted",
    };
  }

  /**
   * Format an entry for writing to file
   */
  private formatEntry(entry: SumEntry): string {
    return `${entry.url} ${entry.hash} ${entry.timestamp} ${entry.trusted ? "trusted" : "untrusted"}`;
  }

  /**
   * Save entries to kly.sum file
   */
  private save(): void {
    if (!this.dirty) {
      return;
    }

    try {
      // Ensure directory exists
      const dir = dirname(this.sumFilePath);
      if (!existsSync(dir)) {
        mkdirSync(dir, { recursive: true });
      }

      // Sort entries by URL for consistent formatting
      const sortedEntries = Array.from(this.entries.values()).sort((a, b) =>
        a.url.localeCompare(b.url),
      );

      // Build file content
      const lines = [
        "# kly.sum - Integrity verification database",
        "# Format: url hash timestamp trusted|untrusted",
        "# DO NOT EDIT THIS FILE MANUALLY",
        "",
        ...sortedEntries.map((entry) => this.formatEntry(entry)),
      ];

      writeFileSync(this.sumFilePath, `${lines.join("\n")}\n`, "utf-8");
      this.dirty = false;
    } catch (error) {
      console.error(`Error: Failed to save kly.sum: ${error}`);
      throw error;
    }
  }

  /**
   * Verify a repository's integrity hash
   *
   * @param url - Full URL (e.g., "github.com/owner/repo@ref")
   * @param hash - Calculated hash to verify
   * @returns "ok" if matches, "mismatch" if different, "new" if first time
   */
  public verify(url: string, hash: string): VerifyResult {
    const entry = this.entries.get(url);

    if (!entry) {
      return "new";
    }

    if (entry.hash === hash) {
      return "ok";
    }

    return "mismatch";
  }

  /**
   * Add or update an entry in kly.sum
   *
   * @param url - Full URL
   * @param hash - Integrity hash
   * @param trusted - Whether user explicitly trusted this code
   */
  public add(url: string, hash: string, trusted = false): void {
    this.entries.set(url, {
      url,
      hash,
      timestamp: Math.floor(Date.now() / 1000),
      trusted,
    });

    this.dirty = true;
    this.save();
  }

  /**
   * Update an existing entry's hash (e.g., user approved new version)
   *
   * @param url - Full URL
   * @param hash - New hash
   * @param trusted - Whether user explicitly trusted this update
   */
  public update(url: string, hash: string, trusted = false): void {
    const existing = this.entries.get(url);

    this.entries.set(url, {
      url,
      hash,
      timestamp: existing?.timestamp ?? Math.floor(Date.now() / 1000),
      trusted,
    });

    this.dirty = true;
    this.save();
  }

  /**
   * Remove an entry from kly.sum
   *
   * @param url - Full URL to remove
   * @returns true if removed, false if not found
   */
  public remove(url: string): boolean {
    const existed = this.entries.delete(url);

    if (existed) {
      this.dirty = true;
      this.save();
    }

    return existed;
  }

  /**
   * Get an entry by URL
   *
   * @param url - Full URL
   * @returns Entry if found, undefined otherwise
   */
  public get(url: string): SumEntry | undefined {
    return this.entries.get(url);
  }

  /**
   * Get all entries
   *
   * @returns Array of all sum entries
   */
  public getAll(): SumEntry[] {
    return Array.from(this.entries.values());
  }

  /**
   * Clear all entries (for testing or reset)
   */
  public clear(): void {
    this.entries.clear();
    this.dirty = true;
    this.save();
  }

  /**
   * Get statistics about the sum file
   */
  public getStats(): {
    total: number;
    trusted: number;
    untrusted: number;
  } {
    const entries = Array.from(this.entries.values());

    return {
      total: entries.length,
      trusted: entries.filter((e) => e.trusted).length,
      untrusted: entries.filter((e) => !e.trusted).length,
    };
  }
}
